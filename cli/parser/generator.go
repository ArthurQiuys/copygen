package parser

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"strings"
)

// parseKeep parses the generator's setup file for data that is kept in the generated file.
// assigns values to the parser's convert options.
func (p *Parser) parseKeep() ([]byte, error) {
	// Do not modify the original AST file and fileset.
	fileset := token.NewFileSet()
	file, err := parser.ParseFile(fileset, p.Setpath, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("An error occurred parsing the specified .go setup file: %v.\n%v", p.Setpath, err)
	}

	// traverse the AST to locate the `type Copygen interface` and assign options respectively.
	for i := len(file.Decls) - 1; i > -1; i-- {
		switch x := file.Decls[i].(type) {
		case *ast.GenDecl:
			if it, ok := assertCopygenInterface(x); ok {
				// assign and remove respective `type Copygen interface` comments
				comments, err := p.assignOptions(x)
				if err != nil {
					return nil, err
				}
				astRemoveComments(file, comments)

				// Keep all declaration objects except for the `type Copygen interface`.
				p.Copygen = it
				file.Decls[i] = file.Decls[len(file.Decls)-1]
				file.Decls = file.Decls[:len(file.Decls)-1]
			}

		// set convert option values.
		case *ast.FuncDecl:
			comments, err := p.assignConvertOptions(x)
			if err != nil {
				return nil, err
			}
			astRemoveComments(file, comments)
		}
	}

	// write the Keep
	buf := new(bytes.Buffer)
	buf.WriteString("// Code generated by github.com/switchupcb/copygen\n// DO NOT EDIT.\n\n")
	err = printer.Fprint(buf, fileset, file)
	if err != nil {
		return []byte{}, err
	}
	return buf.Bytes(), nil
}

// assertCopygenInterface determines if an ast.GenDecl is a Copygen Interface by type assertion.
func assertCopygenInterface(x *ast.GenDecl) (*ast.InterfaceType, bool) {
	if x.Tok == token.TYPE {
		for _, spec := range x.Specs {
			if ts, ok := spec.(*ast.TypeSpec); ok {
				if it, ok := ts.Type.(*ast.InterfaceType); ok && ts.Name.Name == "Copygen" {
					return it, true
				}
			}
		}
	}
	return nil, false
}

// assignOptions initializes function and field-specific options.
// Used in the context of the type Copygen interface.
func (p *Parser) assignOptions(x ast.Node) ([]*ast.Comment, error) {
	var comments []*ast.Comment
	var assignerr error
	ast.Inspect(x, func(node ast.Node) bool {
		switch xcg := node.(type) {
		case *ast.CommentGroup:
			for i := 0; i < len(xcg.List); i++ {
				// do not use the Doc above the node as an option
				if xcg.List[i].Slash > x.Pos() {
					text := xcg.List[i].Text
					splitcomments := strings.Fields(text[2:])

					// map[comment]map[optionname]map[]
					// determine if the comment is an option.
					if len(splitcomments) >= 1 {
						category := splitcomments[0]
						option := strings.Join(splitcomments[1:], " ")
						switch category {
						case "deepcopy":
							opt, err := parseDeepcopy(option)
							if err != nil {
								assignerr = err
								return false
							}
							p.Options[text] = *opt
						case "depth":
							opt, err := parseDepth(option)
							if err != nil {
								assignerr = err
								return false
							}
							p.Options[text] = *opt
						case "map":
							opt, err := parseMap(option)
							if err != nil {
								assignerr = err
								return false
							}
							p.Options[text] = *opt
						default:
							p.Options[text] = Option{
								Category: "custom",
								Regex:    nil,
								Value:    map[string]string{category: option},
							}
						}
					}
				}
				// all type Copygen interface comments will be removed.
				comments = append(comments, xcg.List[i])
			}
		}
		return true
	})
	return comments, assignerr
}

// assignConvertOptions initializes convert options.
// Used in the context of functions other than the type Copygen interface.
func (p *Parser) assignConvertOptions(x *ast.FuncDecl) ([]*ast.Comment, error) {
	var comments []*ast.Comment
	var assignerr error
	ast.Inspect(x, func(node ast.Node) bool {
		switch xcg := node.(type) {
		case *ast.CommentGroup:
			for i := 0; i < len(xcg.List); i++ {
				text := xcg.List[i].Text
				splitcomments := strings.Fields(text[2:])

				// map[comment]map[optionname]map[]
				// determine if the comment is a convert option.
				if len(splitcomments) == 3 {
					category := splitcomments[0]
					option := strings.Join(splitcomments[1:], " ")
					switch category {
					case "convert":
						opt, err := parseConvert(option, x.Name.Name)
						if err != nil {
							assignerr = err
							return false
						}
						p.Options[text] = *opt
						comments = append(comments, xcg.List[i])
					}
				}
			}
		}
		return true
	})
	return comments, assignerr
}

// astRemoveComments removes comments from an *ast.File.
func astRemoveComments(file *ast.File, comments []*ast.Comment) {
	clength := len(comments)
	for i := 0; i < len(file.Comments); i++ {
		cg := file.Comments[i]
		// traverse through the comment group
		for j := 0; j < len(cg.List); j++ {
			// remove the comments by comparison
			for c := 0; c < clength; c++ {
				if cg.List[j] == comments[c] {
					// remove from the comment group top-down.
					if j-1 > -1 {
						cg.List[j].Text = cg.List[j-1].Text
						cg.List[j-1].Text = "  " // printer: "" and " " give an out of bounds error
					} else {
						cg.List[j].Text = "  " // printer: "" and " " give an out of bounds error
					}
					break
				}
			}
		}
	}
}
