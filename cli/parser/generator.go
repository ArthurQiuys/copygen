package parser

import (
	"bytes"
	"go/ast"
	"go/printer"
	"go/token"
	"strings"

	"github.com/switchupcb/copygen/cli/models"
)

// parseKeep parses the generator's setup file for data that is kept in the generated file.
// modifies the parser file.
func (p *Parser) parseKeep(gen *models.Generator) ([]byte, error) {
	// Keep all declaration objects except for the type Copygen interface.
	for i := len(p.SetupFile.Decls) - 1; i > -1; i-- {
		switch x := p.SetupFile.Decls[i].(type) {
		case *ast.GenDecl:
			var found bool
			if x.Tok == token.TYPE {
				for _, spec := range x.Specs {
					if ts, ok := spec.(*ast.TypeSpec); ok {
						if _, ok := ts.Type.(*ast.InterfaceType); ok && ts.Name.Name == "Copygen" {
							found = true
							p.SetupFile.Decls[i] = p.SetupFile.Decls[len(p.SetupFile.Decls)-1]
							p.SetupFile.Decls = p.SetupFile.Decls[:len(p.SetupFile.Decls)-1]
						}
					}
				}
			}

			if found {
				// remove respective comments
				ast.Inspect(x, func(node ast.Node) bool {
					switch xcg := node.(type) {
					case *ast.CommentGroup:
						xcg.List = nil
					}
					return true
				})
			}
		default:
			// keep comment options (`// comment: ...` -> `// ...`
			ast.Inspect(x, func(node ast.Node) bool {
				switch xcg := node.(type) {
				case *ast.CommentGroup:
					for i := 0; i < len(xcg.List); i++ {
						splitcomment := splitASTComment(xcg.List[i])
						if len(splitcomment) >= 2 && splitcomment[0] == "comment" {
							xcg.List[i].Text = "//" + strings.Join(splitcomment[1:], "")
							return false
						} else {
							xcg.List[i].Text = "  " // printer: "" and " " give an out of bounds error
						}
					}
				}
				return true
			})
		}
	}

	buf := new(bytes.Buffer)
	buf.WriteString("// Code generated by github.com/switchupcb/copygen\n// DO NOT EDIT.\n\n")
	err := printer.Fprint(buf, p.Fileset, p.SetupFile)
	if err != nil {
		return []byte{}, err
	}
	return buf.Bytes(), nil
}

// splitASTComment splits an *ast.Comment for options parsing without the //.
func splitASTComment(c *ast.Comment) []string {
	// Remove the `//` and normalize space.
	comment := strings.TrimSpace(c.Text[2:])

	// Separate comment into 1 (option) + n parts
	return strings.Split(comment, ":")
}
