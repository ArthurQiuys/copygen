package parser

import (
	"bytes"
	"go/ast"
	"go/printer"
	"go/token"

	"github.com/switchupcb/copygen/cli/models"
)

// parseKeep parses the generator's setup file for data that is kept in the generated file.
// modifies the parser file.
func (p *Parser) parseKeep(gen *models.Generator) ([]byte, error) {
	// Keep all declaration objects except for the type Copygen interface.
	for i := len(p.SetupFile.Decls) - 1; i > -1; i-- {
		switch x := p.SetupFile.Decls[i].(type) {
		case *ast.GenDecl:
			var found bool
			if x.Tok == token.TYPE {
				for _, spec := range x.Specs {
					if ts, ok := spec.(*ast.TypeSpec); ok {
						if _, ok := ts.Type.(*ast.InterfaceType); ok && ts.Name.Name == "Copygen" {
							found = true
							p.SetupFile.Decls[i] = p.SetupFile.Decls[len(p.SetupFile.Decls)-1]
							p.SetupFile.Decls = p.SetupFile.Decls[:len(p.SetupFile.Decls)-1]
						}
					}
				}
			}

			if found {
				// remove respective comments
				ast.Inspect(x, func(node ast.Node) bool {
					switch xcg := node.(type) {
					case *ast.CommentGroup:
						xcg.List = nil
					}
					return true
				})
			}
		default:
			// keep all comments that aren't options (where options are in format `// option: ...`)
			ast.Inspect(x, func(node ast.Node) bool {
				switch xcg := node.(type) {
				case *ast.CommentGroup:
					for i := 0; i < len(xcg.List); i++ {
						splitcomment := splitASTComment(xcg.List[i], ":")
						var rm bool
						switch splitcomment[0] {
						case "convert":
							rm = true
						case "depth":
							rm = true
						case "deepcopy":
							rm = true
						case "map":
							rm = true
						}
						// remove from the top-down.
						if rm {
							if i-1 > -1 {
								xcg.List[i].Text = xcg.List[i-1].Text
							}
							xcg.List[i-1].Text = "  " // printer: "" and " " give an out of bounds error
						}
					}
				}
				return true
			})
		}
	}

	buf := new(bytes.Buffer)
	buf.WriteString("// Code generated by github.com/switchupcb/copygen\n// DO NOT EDIT.\n\n")
	err := printer.Fprint(buf, p.Fileset, p.SetupFile)
	if err != nil {
		return []byte{}, err
	}
	return buf.Bytes(), nil
}
