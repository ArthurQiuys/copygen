package parser

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
)

// parseKeep parses the generator's setup file for data that is kept in the generated file.
// assigns values to the parser's convert options.
func (p *Parser) parseKeep() ([]byte, error) {
	// Do not modify the original AST file and fileset.
	fileset := token.NewFileSet()
	file, err := parser.ParseFile(fileset, p.Setpath, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("An error occurred parsing the specified .go setup file: %v.\n%v", p.Setpath, err)
	}

	for i := len(file.Decls) - 1; i > -1; i-- {
		switch x := file.Decls[i].(type) {
		// Keep all declaration objects except for the type Copygen interface.
		case *ast.GenDecl:

			var found bool
			if x.Tok == token.TYPE {
				for _, spec := range x.Specs {
					if ts, ok := spec.(*ast.TypeSpec); ok {
						if _, ok := ts.Type.(*ast.InterfaceType); ok && ts.Name.Name == "Copygen" {
							found = true
							file.Decls[i] = file.Decls[len(file.Decls)-1]
							file.Decls = file.Decls[:len(file.Decls)-1]
						}
					}
				}
			}

			// remove respective type Copygen interface comments
			if found {
				removeNodeComments(x)
			}

		// assign convert option values.
		case *ast.FuncDecl:
			ast.Inspect(x, func(node ast.Node) bool {
				switch xcg := node.(type) {
				case *ast.CommentGroup:
					for _, comment := range xcg.List {
						splitoption := splitASTComment(comment, ":")
						if splitoption[0] == "convert" {
							p.Options[comment.Text].Value[0] = x.Name.Name
						}
					}
				}
				return true
			})
			removeOptionComments(x)
		default:
			removeOptionComments(x)
		}
	}

	buf := new(bytes.Buffer)
	buf.WriteString("// Code generated by github.com/switchupcb/copygen\n// DO NOT EDIT.\n\n")
	err = printer.Fprint(buf, fileset, file)
	if err != nil {
		return []byte{}, err
	}
	return buf.Bytes(), nil
}

// removeNodeComments removes all the comments from an ast.Node.
func removeNodeComments(x ast.Node) {
	ast.Inspect(x, func(node ast.Node) bool {
		switch xcg := node.(type) {
		case *ast.CommentGroup:
			xcg.List = nil
		}
		return true
	})
}

// removeOptionComments inspects an ast.Node for its comments and removes them if they're options.
func removeOptionComments(x ast.Node) {
	// keep all comments that aren't options (where options are in format `// option: ...`)
	ast.Inspect(x, func(node ast.Node) bool {
		switch xcg := node.(type) {
		case *ast.CommentGroup:
			for i := 0; i < len(xcg.List); i++ {
				splitcomment := splitASTComment(xcg.List[i], ":")
				var rm bool

				// remove `/* */` comments
				if xcg.List[i].Text[:2] == "/*" {
					rm = true
				}

				// a valid comment can have `:` (i.e `// This is an example: ABC`)
				switch splitcomment[0] {
				case "convert":
					rm = true
				case "depth":
					rm = true
				case "deepcopy":
					rm = true
				case "map":
					rm = true
				}
				// remove from the top-down.
				if rm {
					if i-1 > -1 {
						xcg.List[i].Text = xcg.List[i-1].Text
						xcg.List[i-1].Text = "  " // printer: "" and " " give an out of bounds error
					} else {
						xcg.List[i].Text = "  " // printer: "" and " " give an out of bounds error
					}
				}
			}
		}
		return true
	})
}
