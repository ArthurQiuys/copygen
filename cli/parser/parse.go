// Package parser parses a setup file's functions, types, and fields using an Abstract Syntax Tree.
package parser

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"path/filepath"

	"github.com/switchupcb/copygen/cli/models"
	"github.com/switchupcb/copygen/cli/parser/options"
	"golang.org/x/tools/go/packages"
)

// Parser represents a parser that parses Abstract Syntax Tree data into models.
type Parser struct {
	// CommentOptionMap represents a map of function (field-specific) options to comments.
	CommentOptionMap CommentOptionMap

	// The fileset of the parser.
	Fileset *token.FileSet

	// The setup file as an Abstract Syntax Tree.
	SetupFile *ast.File

	// A key value cache used to reduce the amount of package load operations during a field search.
	pkgcache map[string][]*packages.Package

	// The last package to be loaded by a Locater.
	LastLocated *packages.Package

	// A key value cache used to reduce the amount of AST operations during a field search.
	fieldcache map[string]*models.Field

	// The setup filepath.
	Setpath string

	// ConvertOptions represents a list of convert options (for convert functions).
	ConvertOptions []*options.Option
}

// Parse parses a generator's setup file.
func Parse(gen *models.Generator) error {
	// determine the actual filepath of the setup.go file.
	absfilepath, err := filepath.Abs(filepath.Join(filepath.Dir(gen.Loadpath), gen.Setpath))
	if err != nil {
		return err
	}

	// Setup the parser.
	p := Parser{Setpath: absfilepath}
	p.Fileset = token.NewFileSet()
	p.SetupFile, err = parser.ParseFile(p.Fileset, absfilepath, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("an error occurred parsing the specified .go setup file: %v\n%v", gen.Setpath, err)
	}

	p.fieldcache = make(map[string]*models.Field)
	p.pkgcache = make(map[string][]*packages.Package)
	pkgs, err := p.loadPackage("file=" + p.Setpath)
	if err != nil {
		return err
	}

	for _, pkg := range pkgs {
		if p.SetupFile.Name == nil {
			return fmt.Errorf("the setup file must declare a package: %v", p.Setpath)
		} else if p.SetupFile.Name.Name == pkg.Name {
			p.LastLocated = pkg
			break
		}
	}

	if p.LastLocated == nil {
		return fmt.Errorf("the setup file's package could not be loaded correctly: %v", p.Setpath)
	}

	// Write the Keep.
	removed, err := Keep(p.SetupFile)
	if err != nil {
		return err
	}

	if removed.Copygen == nil {
		return fmt.Errorf("the \"type Copygen interface\" could not be found in the setup file")
	}

	buf := new(bytes.Buffer)
	buf.WriteString("// Code generated by github.com/switchupcb/copygen\n// DO NOT EDIT.\n\n")
	if err := printer.Fprint(buf, p.Fileset, p.SetupFile); err != nil {
		return fmt.Errorf("an error occurred writing the code that will be kept after generation\n%v", err)
	}

	gen.Keep = buf.Bytes()

	// Parse ast.Comments into Options.
	p.ConvertOptions = removed.ConvertOptions
	p.CommentOptionMap, err = MapOptions(removed.Comments)
	if err != nil {
		return fmt.Errorf("an error occurred while parsing comments for options\n%v", err)
	}

	// Analyze the `type Copygen Interface` for function and field data.
	if gen.Functions, err = p.parseFunctions(removed.Copygen); err != nil {
		return fmt.Errorf("%w", err)
	}

	return nil
}

// pLoadMode represents the load mode required for sufficient information during package load.
const pLoadMode = packages.NeedName + packages.NeedImports + packages.NeedTypes + packages.NeedSyntax + packages.NeedTypesInfo

// loadPackage loads a package.
func (p *Parser) loadPackage(importPath string) ([]*packages.Package, error) {
	if pkgs, exists := p.pkgcache[importPath]; exists {
		return pkgs, nil
	}

	config := &packages.Config{Mode: pLoadMode, Logf: nil}

	pkgs, err := packages.Load(config, importPath)
	if err != nil {
		return nil, fmt.Errorf("an error occurred loading a package from the GOPATH with import: %v.\n%v", importPath, err)
	}

	p.pkgcache[importPath] = pkgs

	return pkgs, nil
}
